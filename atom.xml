<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Isatis&#39; Blog</title>
  
  <subtitle>路在远方</subtitle>
  <link href="http://www.isatis.top/atom.xml" rel="self"/>
  
  <link href="http://www.isatis.top/"/>
  <updated>2021-01-02T12:35:57.289Z</updated>
  <id>http://www.isatis.top/</id>
  
  <author>
    <name>Isatis.Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内存优化分析(1)</title>
    <link href="http://www.isatis.top/2021/01/02/mm-1/"/>
    <id>http://www.isatis.top/2021/01/02/mm-1/</id>
    <published>2021-01-02T01:19:39.000Z</published>
    <updated>2021-01-02T12:35:57.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存优化分析-1"><a href="#内存优化分析-1" class="headerlink" title="内存优化分析(1)"></a>内存优化分析(1)</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>内存资源是宝贵的，内存能少用决不多用。而想要如何优化内存使用的前提就是要找到是哪里使用了内存？用了多大了内存？需要注意的是，我们并不是调用malloc申请了的大的内存，就一定占用了那么大的内存。因为linux会在我们用到的时候才会给我们分配实际的物理内存。例如下面的，虽然申请了4100kB的虚拟地址空间，但实际使用的物理内存也只有4KB。</p><pre class="line-numbers language-none"><code class="language-none">b49b7000-b4db8000 rw-p 00000000 00:00 0Size:               4100 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   4 kBPss:                   4 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         4 kBReferenced:            4 kBAnonymous:             4 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 k<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>所以申请的内存大小不等于实际使用的物理内存，某些时候申请了很多，但实际根本不会用到。建议的思路在于看到哪一段占用了物理内存，再对应到代码中去，对这块业务进行优化。而通过查看进程的smaps,可以看到程序实际运行起来，物理内存实际占用情况。但问题就在于smap出来的信息，知道了哪个地址片段占用了大量的内存（Rss值）但是我只有一个地址信息，而如何确认smaps对应到代码中的变量或者malloc操作呢？下面以一个实例来分析下</p><p>代码仓库：<a href="https://github.com/isatispro/mm.git">https://github.com/isatispro/mm.git</a></p><p>实验平台：树莓派4B</p><h2 id="2-主要内存消耗点及优化点"><a href="#2-主要内存消耗点及优化点" class="headerlink" title="2.主要内存消耗点及优化点"></a>2.主要内存消耗点及优化点</h2><p>程序 = 代码 + 数据结构。真正代码段上能优化的很少，数据结构的核心还是在数据上，所以分析和优化的点多数都在数据上。数据的优化点可以从我们定义的全局变量，调用的malloc申请的内存上先下手,其中全局变量又会分到.data段和.bss段，而malloc又会分为brk的内存和mmap的内存。</p><h3 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1. 全局变量"></a>1. 全局变量</h3><p>mm</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">PAGE_SIZE</span> <span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">SIZE_1K</span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span></span></span><span class="token keyword">char</span> <span class="token operator">*</span>pText <span class="token operator">=</span> <span class="token string">"The  mallopt()  function  adjusts parameters that control the behavior of the memory-allocation functions (see malloc(3)).  The param argument specifies the parameter to be modi‐fied, and value specifies the new value for that parameter."</span><span class="token punctuation">;</span><span class="token keyword">int</span> gData<span class="token punctuation">[</span>PAGE_SIZE <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> gBss<span class="token punctuation">[</span>PAGE_SIZE <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>libmm.so</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">PAGE_SIZE</span> <span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span></span></span><span class="token keyword">char</span> <span class="token operator">*</span>pTextLib <span class="token operator">=</span> <span class="token string">"The  mallopt()  function  adjusts parameters that control the behavior of the memory-allocation functions (see malloc(3)).  The param argument specifies the parameter to be modi‐fied, and value specifies the new value for that parameter."</span><span class="token punctuation">;</span><span class="token keyword">int</span> gDataLib<span class="token punctuation">[</span>PAGE_SIZE <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> gBssLib<span class="token punctuation">[</span>PAGE_SIZE <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在函数内部定义的变量，会被分配在栈空间。而已经初始化的全局变量放在.data段，未初始化的在.bss段，这部分会在程序加载时就映射到内存空间上。</p><h4 id="已初始化的全局变量（-data）"><a href="#已初始化的全局变量（-data）" class="headerlink" title="- 已初始化的全局变量（.data）"></a>- 已初始化的全局变量（.data）</h4><p>先看下smaps的情况</p><details><summary>mm</summary><pre><code>00010000-00011000 r-xp 00000000 00:28 2752530    /mnt/nfs/mm/mmSize:                  4 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   4 kBPss:                   4 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         4 kBPrivate_Dirty:         0 kBReferenced:            4 kBAnonymous:             0 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:        0VmFlags: rd ex mr mw me dw00020000-00021000 r--p 00000000 00:28 2752530    /mnt/nfs/mm/mmSize:                  4 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   4 kBPss:                   4 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         4 kBReferenced:            4 kBAnonymous:             4 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:        0VmFlags: rd mr mw me dw ac00021000-01022000 rw-p 00001000 00:28 2752530    /mnt/nfs/mm/mmSize:              16388 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                  64 kBPss:                  64 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:        56 kBPrivate_Dirty:         8 kBReferenced:           64 kBAnonymous:             8 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:        0VmFlags: rd wr mr mw me dw ac01022000-02022000 rw-p 00000000 00:00 0Size:              16384 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   0 kBPss:                   0 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         0 kBReferenced:            0 kBAnonymous:             0 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:        0VmFlags: rd wr mr mw me ac</code></pre></details><details><summary>limmm.so</summary><pre><code>b4f06000-b4f07000 r-xp 00000000 00:28 2752531    /mnt/nfs/mm/libmm.soSize:                  4 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   4 kBPss:                   4 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         4 kBPrivate_Dirty:         0 kBReferenced:            4 kBAnonymous:             0 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:        0VmFlags: rd ex mr mw meb4f07000-b4f16000 ---p 00001000 00:28 2752531    /mnt/nfs/mm/libmm.soSize:                 60 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   0 kBPss:                   0 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         0 kBReferenced:            0 kBAnonymous:             0 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:        0VmFlags: mr mw meb4f16000-b4f17000 r--p 00000000 00:28 2752531    /mnt/nfs/mm/libmm.soSize:                  4 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   4 kBPss:                   4 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         4 kBReferenced:            4 kBAnonymous:             4 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:        0VmFlags: rd mr mw me acb4f17000-b5f18000 rw-p 00001000 00:28 2752531    /mnt/nfs/mm/libmm.soSize:              16388 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                  64 kBPss:                  64 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:        56 kBPrivate_Dirty:         8 kBReferenced:           64 kBAnonymous:             8 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:        0VmFlags: rd wr mr mw me acb5f18000-b6f18000 rw-p 00000000 00:00 0Size:              16384 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   0 kBPss:                   0 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         0 kBReferenced:            0 kBAnonymous:             0 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:        0VmFlags: rd wr mr mw me ac</code></pre></details>我们的全局变量一定是可读可写的，所以它的权限必定有读写。而且因为已经初始化的全局变量是有实际的数据内容，并且保存在程序的文件中，所以这部分内存是有文件背景的映射，所以有两段我们可以猜测它会是.data段的映射。<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">00021000-01022000 rw-p 00001000 00:28 2752530    /mnt/nfs/mm/mmSize:              16388 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                  64 kBPss:                  64 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:        56 kBPrivate_Dirty:         8 kBReferenced:           64 kBAnonymous:             8 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd wr mr mw me dw ac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">b4f17000-b5f18000 rw-p 00001000 00:28 2752531    /mnt/nfs/mm/libmm.soSize:              16388 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                  64 kBPss:                  64 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:        56 kBPrivate_Dirty:         8 kBReferenced:           64 kBAnonymous:             8 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:         0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd wr mr mw me ac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="再看下段表"><a href="#再看下段表" class="headerlink" title="再看下段表"></a>再看下段表</h5><p>mm</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[22] .data             PROGBITS        00021034 001034 100000c 00  WA  0   0  4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>libmm.so</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[19] .data             PROGBITS        00011038 001038 1000008 00  WA  0   0  4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>mm</li></ul><p>.data 段表的Addr是00021034。smaps段的地址是 00021000-01022000。00021034是位于00021000-01022000中间的。</p><ul><li>libmm.so</li></ul><p>.data 段表中的Addr是00011038。而smaps中的地址是 b4f17000-b5f18000。需要注意的是动态库段表中的不是真正的虚拟地址。计算时需要减去动态库的基地址。从smaps看到libmm.so加载的基地址是 b4f06000 。b4f17000-b5f18000减去基址址为 00011000-1012000。00011038也是位于00011000-1012000内。</p><p>然后看看全局变量的符号表，<br>可以mm看到gData这个变量的地址是00021040，位于地址范围00021000-01022000内</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">110: 02021044     0 NOTYPE  GLOBAL DEFAULT   23 _end111: 00010478     0 FUNC    GLOBAL DEFAULT   13 _start112: 02021044     0 NOTYPE  GLOBAL DEFAULT   23 __end__113: 01021040     0 NOTYPE  GLOBAL DEFAULT   23 __bss_start114: 00010568   192 FUNC    GLOBAL DEFAULT   13 main115: 00021040 0x1000000 OBJECT  GLOBAL DEFAULT   22 gData116: 01021040     0 OBJECT  GLOBAL HIDDEN    22 __TMC_END__117: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable118: 00000000     0 FUNC    GLOBAL DEFAULT  UND abort@@GLIBC_2.4119: 000103ec     0 FUNC    GLOBAL HIDDEN    11 _ini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>libmm.so 中gDataLib的0001103c，位于地址范围00011000-1012000内</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">75: 00000384     0 NOTYPE  LOCAL  DEFAULT   10 $d76: 00000388     0 NOTYPE  LOCAL  DEFAULT   10 $a77: 0001103c 0x1000000 OBJECT  GLOBAL DEFAULT   19 gDataLib78: 00000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@@GLIBC_2.479: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab80: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@@GLIBC_2.481: 0101103c     4 OBJECT  GLOBAL DEFAULT   19 pTextLib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在基本可以确认smaps中00021000-01022000和b4f17000-b5f18000这两段分别是mm和libmm.so的.data段的映射。它们现在分别占用了64KB。虽然它们申请的远大于这个值，但实际上就占用的物理内存并不多。另外在代码里并没有去该变过这段地址内的内容，所以它们的Dirty部分都不大，而这些页面的，后续都是可以交换被拿出来给其它地方用的。</p><p>虽然分析到这里基本可以确认，但我们仍然可以在代码里打印出这两个变量的地址确认下。gData的地址为0x21040，和通过符号表里查到的是一样的，另外gDataLib的地址为0xb4f1703c，减去libmm.so加载的基址0xb4f06000，得到0x1103c，也与符号表里查到的一样。</p><p>mm:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">data addr:0x21040<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>libmm.so</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">data addr:0xb4f1703c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存优化分析-1&quot;&gt;&lt;a href=&quot;#内存优化分析-1&quot; class=&quot;headerlink&quot; title=&quot;内存优化分析(1)&quot;&gt;&lt;/a&gt;内存优化分析(1)&lt;/h1&gt;&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="内存优化&amp;分析" scheme="http://www.isatis.top/categories/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96-%E5%88%86%E6%9E%90/"/>
    
    
    <category term="内存优化" scheme="http://www.isatis.top/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
    <category term="内存管理" scheme="http://www.isatis.top/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>内存优化分析(2)</title>
    <link href="http://www.isatis.top/2021/01/02/mm-2/"/>
    <id>http://www.isatis.top/2021/01/02/mm-2/</id>
    <published>2021-01-02T01:19:39.000Z</published>
    <updated>2021-01-03T13:12:05.604Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存优化分析-2"><a href="#内存优化分析-2" class="headerlink" title="内存优化分析(2)"></a>内存优化分析(2)</h1><h4 id="未初始化的全局变量（-bss）"><a href="#未初始化的全局变量（-bss）" class="headerlink" title="- 未初始化的全局变量（.bss）"></a>- 未初始化的全局变量（.bss）</h4><p>没有初始化过的变量被放在.bss区。这部分存储时没的占用磁盘空间，程序运行起来，这段会被map到一个虚拟地址上。因为没有实际的文件存储，所以映射出来也没有文件背景，但它们通常都会紧跟着有其对应的文件背景片段。对应到smaps的信息，可以猜测下面这两段可能就是mm和libmm.so的.bss段映射。</p><p>mm</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">01022000-02022000 rw-p 00000000 00:00 0Size:              16384 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   0 kBPss:                   0 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         0 kBReferenced:            0 kBAnonymous:             0 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd wr mr mw me ac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>libmm.so</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">b5f18000-b6f18000 rw-p 00000000 00:00 0Size:              16384 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   0 kBPss:                   0 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         0 kBReferenced:            0 kBAnonymous:             0 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd wr mr mw me ac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>同样的，要确认这两段的“身份”，首先看下对应的段表</li></ol><ul><li><p>mm</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[23] .bss              NOBITS          01021040 1001040 1000004 00  WA  0   0  4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>mm段表的地址是01021040，smaps中的地址段是01022000-02022000。01021040是小于01022000的，相差4032。是否就说明这段不是.bss段呢？别急，“.bss”段的长度是0x1000004,换算下来也差不多是16384KB。大小上是对得上的。另外我们打印出的gBss的地址为0x1021044，与段表上的似乎对得上。我们申请的gBss大小为4096 × 1024。大小为4096KB。实际通过gBss的我们就可以确认gBss有一部分空间是到了01022000-02022000这里面。那行如何验证呢？其实也很简单，我们将gBss变量全部初始化有内容，这时linux就会为我们分配出这4096KB的物理内存，如果这段占用的物理内存变大了，不就证明了我们的猜想了吗？</p></li><li><p>libmm.so</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[20] .bss              NOBITS          01011040 1001040 1000004 00  WA  0   0  4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>libmm.so段表的地址是01011040。smaps中地址段是b5f18000-b6f18000，libmm.so加载的基地址是0xb4f06000。那么这段减去基地址后实际就是0x1012000-0x2012000。01011040与b5f18000还是相差了4032。<br>打印出的0xb5f17044，减去加载的基地址后为0x1011044。与mm的情况一样，同样我们也可以使用mm一样的方法去确认。</p></li></ul><ol start="2"><li>补充</li></ol><p>例子中因为是只一个变量，我们可以直接知道这个变量。但实际工程中变量诸多，我们可以通过.symtab中的Ndx来寻找对应的变量。比如mm中.bss段的为23。那么在.symtab中就不难定位到gBss。<br>mm</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Num:    Value  Size Type    Bind   Vis      Ndx Name89: 01021044 0x1000000 OBJECT  GLOBAL DEFAULT   23 gBss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同样的，libmm.so中.bss段是20。在对应的.symtab中也不难定位到gBssLib</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Num:    Value  Size Type    Bind   Vis      Ndx Name86: 01011044 0x1000000 OBJECT  GLOBAL DEFAULT   20 gBssLi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存优化分析-2&quot;&gt;&lt;a href=&quot;#内存优化分析-2&quot; class=&quot;headerlink&quot; title=&quot;内存优化分析(2)&quot;&gt;&lt;/a&gt;内存优化分析(2)&lt;/h1&gt;&lt;h4 id=&quot;未初始化的全局变量（-bss）&quot;&gt;&lt;a href=&quot;#未初始化的全局变量（-b</summary>
      
    
    
    
    <category term="内存优化&amp;分析" scheme="http://www.isatis.top/categories/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96-%E5%88%86%E6%9E%90/"/>
    
    
    <category term="内存优化" scheme="http://www.isatis.top/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
    <category term="内存管理" scheme="http://www.isatis.top/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>linux内核中的红黑树</title>
    <link href="http://www.isatis.top/2020/10/07/2020-10-07-rbtree/"/>
    <id>http://www.isatis.top/2020/10/07/2020-10-07-rbtree/</id>
    <published>2020-10-06T16:00:00.000Z</published>
    <updated>2020-12-27T12:05:01.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-内核中的红黑树"><a href="#Linux-内核中的红黑树" class="headerlink" title="Linux 内核中的红黑树"></a>Linux 内核中的红黑树</h1><h2 id="1-红黑树是什么玩意？"><a href="#1-红黑树是什么玩意？" class="headerlink" title="1. 红黑树是什么玩意？"></a>1. 红黑树是什么玩意？</h2><p>红黑树是一种自平衡的二叉搜索树，它等价于2-3-4树，相对于AVL树，它有更好的插入与删除性能，在Linux内核中被广泛使用。Linux内核中有已经实现好的红黑树，可以直接使用，并且内核文档中也有使用说明。关于红黑树的一些资料，可以参考<a href="http://en.wikipedia.org/wiki/Red-black_tree">红黑树在wiki上的文档</a></p><h2 id="2-代码在哪儿？"><a href="#2-代码在哪儿？" class="headerlink" title="2. 代码在哪儿？"></a>2. 代码在哪儿？</h2><h3 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件:"></a><strong>代码文件:</strong></h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lib/rbtree.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="头文件："><a href="#头文件：" class="headerlink" title="头文件："></a><strong>头文件：</strong></h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">include/linux/rbtree.hinclude/linux/rbtree_augmented.h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果要移植红黑树只需要将上面几个文件拷出来，再对一些用到的宏进行处理就行了</p><h2 id="3-节点解析"><a href="#3-节点解析" class="headerlink" title="3. 节点解析"></a>3. 节点解析</h2><p>第一次查看内核中红黑树的节点，觉得很奇怪，因为它简单了！抛开红黑树本身，这是它实现的高明之处，也是难点。wiki中红黑树的节点定义是这样的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">color_t</span> <span class="token punctuation">{</span> BLACK<span class="token punctuation">,</span> RED <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>  Node<span class="token operator">*</span> parent<span class="token punctuation">;</span>  Node<span class="token operator">*</span> left<span class="token punctuation">;</span>  Node<span class="token operator">*</span> right<span class="token punctuation">;</span>  <span class="token keyword">enum</span> <span class="token class-name">color_t</span> color<span class="token punctuation">;</span>  <span class="token keyword">int</span> key<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在linux内核中，红黑树的节点定义是这样的</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span>  __rb_parent_color<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>rb_right<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>rb_left<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* The alignment might seem pointless, but allegedly CRIS needs it */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，内核中的红黑树相比普通的定义少了两个成员，普通的有5个，到了这边就只有3个了，那其它2个去哪儿了？首先是指向父节点的指针及节点颜色，对比普通定义，Linux内核中只有一个节点<strong>__rb_parent_color</strong>，从命名猜想可能是这一个成员干了人家两个成员的事？先看看获取父节点和获取当前节点颜色是如何实现的</p><h3 id="1-parent与color节点实现"><a href="#1-parent与color节点实现" class="headerlink" title="1. parent与color节点实现"></a>1. <em>parent与color节点实现</em></h3><h4 id="获取父节点"><a href="#获取父节点" class="headerlink" title="获取父节点"></a>获取父节点</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">rb_parent</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">3</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="获取节点颜色"><a href="#获取节点颜色" class="headerlink" title="获取节点颜色"></a>获取节点颜色</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token expression">RB_RED<span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token expression">RB_BLACK<span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__rb_color</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__rb_is_black</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span>  <span class="token function">__rb_color</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__rb_is_red</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">__rb_color</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">rb_color</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span>       <span class="token function">__rb_color</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">rb_is_red</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span>      <span class="token function">__rb_is_red</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">rb_is_black</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span>    <span class="token function">__rb_is_black</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="父节点获取分析"><a href="#父节点获取分析" class="headerlink" title="父节点获取分析"></a>父节点获取分析</h4><p>要注意的是long类型在不同系统的长度是不一样的，在32位系统为32位，在64位系统为64位，下面以32位系统来作分析。父节点获取就是把<strong>__rb_parent_color</strong>中除了最后两位去掉的内容去掉，如下：</p>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"> <span class="token number">3</span>： <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0011</span><span class="token operator">~</span><span class="token number">3</span>： <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1100</span> <span class="token comment">/* ~3就是最后两位为0的数 */</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">3</span> <span class="token comment">/* 此处对~3进行 &amp; 运算就是把(r)-&gt;__rb_parent_color的最后两位清掉 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="节点颜色的获取分析"><a href="#节点颜色的获取分析" class="headerlink" title="节点颜色的获取分析"></a>节点颜色的获取分析</h4><p>节点颜色最后都是将<strong>__rb_parent_color</strong>给到<strong>__rb_color</strong>这个宏来实现，<strong>__rb_color</strong>中将<strong>__rb_parent_colorr</strong>与1进行 &amp; 运算，其实就是将最后一位取出，最后一位就是节点的颜色。</p><h4 id="为什么父节点可以和颜色用同一个成员变量？"><a href="#为什么父节点可以和颜色用同一个成员变量？" class="headerlink" title="为什么父节点可以和颜色用同一个成员变量？"></a>为什么父节点可以和颜色用同一个成员变量？</h4><p>  <strong>__rb_parent_colorr</strong>这个成员的前30位存了父节点的地址，最后一位存了节点的颜色，节点颜色不难理解，那么为什么在最后一写入颜色不会影响父节点的地址呢？32位系统的地址明明是32位，为什么只用到30位？</p><p>  其实最后两位真不会用到，因为在32位的操作系统中，这个结构体在内存中是按照4字节对齐存储，两个指针变量4字节，long类型的变量同样也是占用4节点，而4字节对齐下，它们的地址都会是4的倍数，相应的地址最后两位一定为0。另外值得注意的是虽然这里进行了手动对齐*<strong>attribute</strong>((aligned(sizeof(long))))*，但即使不进行手动对齐，还是会4字节对齐，注释说根据CRIS会需要用到。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-||      __rb_parent_colorr       |       rb_right                |        rb_left                |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  相应的在64位系统上，<strong>rb_node</strong>会按照8字节对齐存储，届时最后三位都不会用到，所以在64位系统上也同样适用。</p><h3 id="2-节点key"><a href="#2-节点key" class="headerlink" title="2. 节点key"></a>2. <strong>节点key</strong></h3><p>  红黑树的节点并没有定义节点内容的成员，如果要使用红黑树就需要将<strong>rb_node</strong>这个节点内嵌到你的结构体中，获取节点时由<strong>rb_entry</strong>或者是<strong>container_of</strong>宏来获取自定义结构体的entry地址</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> <span class="token operator">*</span>keystring<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 而 <strong>rb_entry</strong>实质也是<strong>container_of</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token expression"><span class="token function">rb_entry</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> type<span class="token punctuation">,</span> member<span class="token punctuation">)</span> <span class="token function">container_of</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> type<span class="token punctuation">,</span> member）</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  <strong>container_of</strong> 这个宏可算是内核中的一个绝活了，例如上面定义的mytype结构休，使用红黑树进行增删改查时，我们找到的得到的只有 <strong>rb_node</strong> 节点，我们可以通过 <strong>container_of</strong> 宏获取到对应的mytpye地址， <strong>container_of</strong> 的原理就是通过 <strong>rb_node</strong> 的地址减去其在结构体中的偏移，从而得到结构体的entry地址.这样也就相当节点的 <strong>key</strong> 从红黑树中取出，外挂在结构体中，只将红黑树的平衡操作统一实现。<br>  </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">|---------|-------||keystring|rb_node|address_of(data) = address_of(rb_node) - offset_of(rb_node)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>使用  <strong>container_of</strong>宏操作<br>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mytype</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="3-内核文档中的一些操作示例"><a href="#3-内核文档中的一些操作示例" class="headerlink" title="3. 内核文档中的一些操作示例"></a>3. <strong>内核文档中的一些操作示例</strong></h3><h4 id="插入操作-按普通二叉搜索树形式插入，再进行节点调整"><a href="#插入操作-按普通二叉搜索树形式插入，再进行节点调整" class="headerlink" title="插入操作,按普通二叉搜索树形式插入，再进行节点调整"></a>插入操作,按普通二叉搜索树形式插入，再进行节点调整</h4>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">my_insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token operator">*</span>new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>rb_node<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>parent <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">/* Figure out where to put new node */</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>this <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mytype</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>data<span class="token operator">-&gt;</span>keystring<span class="token punctuation">,</span> this<span class="token operator">-&gt;</span>keystring<span class="token punctuation">)</span><span class="token punctuation">;</span>parent <span class="token operator">=</span> <span class="token operator">*</span>new<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span><span class="token operator">-&gt;</span>rb_left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span><span class="token operator">-&gt;</span>rb_right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> FALSE<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* Add new node and rebalance tree. */</span><span class="token function">rb_link_node</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-&gt;</span>node<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> new<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">rb_insert_color</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-&gt;</span>node<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">mysearch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mytree<span class="token punctuation">,</span> <span class="token string">"walrus"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">rb_erase</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-&gt;</span>node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mytree<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">myfree</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="其它操作接口"><a href="#其它操作接口" class="headerlink" title="其它操作接口"></a>其它操作接口</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_first</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 获取中序遍历的第一个节点，也就是最小的节点 */</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_last</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 获取中序遍历的最后一个节点，也就是最大的节点 */</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_next</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 获取当前节点的后继节点 */</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_prev</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 获取当前节点的前驱节点 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-内核中的红黑树&quot;&gt;&lt;a href=&quot;#Linux-内核中的红黑树&quot; class=&quot;headerlink&quot; title=&quot;Linux 内核中的红黑树&quot;&gt;&lt;/a&gt;Linux 内核中的红黑树&lt;/h1&gt;&lt;h2 id=&quot;1-红黑树是什么玩意？&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://www.isatis.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="Algorithm" scheme="http://www.isatis.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Algorithm/"/>
    
    
    <category term="linux" scheme="http://www.isatis.top/tags/linux/"/>
    
    <category term="红黑树" scheme="http://www.isatis.top/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
    <category term="c语言" scheme="http://www.isatis.top/tags/c%E8%AF%AD%E8%A8%80/"/>
    
    <category term="节点对齐" scheme="http://www.isatis.top/tags/%E8%8A%82%E7%82%B9%E5%AF%B9%E9%BD%90/"/>
    
  </entry>
  
</feed>
