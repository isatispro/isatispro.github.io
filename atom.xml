<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Isatis&#39; Blog</title>
  <icon>https://www.gravatar.com/avatar/1621f1b217ca24f037d0d39133570ffb</icon>
  <subtitle>路在远方</subtitle>
  <link href="http://www.isatis.top/atom.xml" rel="self"/>
  
  <link href="http://www.isatis.top/"/>
  <updated>2021-05-15T15:57:29.941Z</updated>
  <id>http://www.isatis.top/</id>
  
  <author>
    <name>Isatis.Yang</name>
    <email>isatispro@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>manjaro配置kdump</title>
    <link href="http://www.isatis.top/2021/05/15/manjaro-pei-zhi-kdump/"/>
    <id>http://www.isatis.top/2021/05/15/manjaro-pei-zhi-kdump/</id>
    <published>2021-05-15T14:51:40.000Z</published>
    <updated>2021-05-15T15:57:29.941Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Kdump和crash"><a href="#Kdump和crash" class="headerlink" title="Kdump和crash"></a>Kdump和crash</h1><p>我们的程序崩溃的时候可以设置生成core文件，通过分析core文件，通过core文件，我们就可以看到问题发生的“车祸现场”。当内核崩溃的时候，可以通过kdump来保存现场情况。应用程序崩溃的时候是内核帮我们保存了发生问题时的内在，而内核崩溃的时候，显然原来的逻辑就不能用了，而Kdump的原理是利用kexec启动到第二个内核，在第二个内核中保存第一个内核的内存情况，然后通过crash分析。所以就需要在第一个内核中保留一部分内存给第二个内核使用，当第一个内核崩溃的时候，通过保留的内存加载第二个内核。<br>关于kdump的配置参考的是arch linux的wikii介绍 <a href="https://wiki.archlinux.org/title/Kdump">Kdump</a></p><h1 id="配置内核选项"><a href="#配置内核选项" class="headerlink" title="配置内核选项"></a>配置内核选项</h1><p>编译更换内核的方法参考上一篇《arch-linux更换内核》，需要确保以下几个选项开启，然后编译更换内核。</p><pre class="line-numbers language-none"><code class="language-none">CONFIG_DEBUG_INFO=yCONFIG_CRASH_DUMP=yCONFIG_PROC_VMCORE=y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="配置启动参数"><a href="#配置启动参数" class="headerlink" title="配置启动参数"></a>配置启动参数</h1><p>要给第二个内核预留内存空间，通过在bootloader中添加命令来实现，需要添加一条“crashkernel=64M”参数，根据arch wiki的介绍，64M足够捕捉12G内存的设备的内存了。arch wiki上介绍的是syslinux的配置方法，manjaro默认使用的是grub来引导的，grub配置可以采用以下步骤</p><h2 id="1-编辑-etc-default-grub文件，在GRUB-CMDLINE-LINUX-DEFAULT中添加crashkernel-512M"><a href="#1-编辑-etc-default-grub文件，在GRUB-CMDLINE-LINUX-DEFAULT中添加crashkernel-512M" class="headerlink" title="1. 编辑/etc/default/grub文件，在GRUB_CMDLINE_LINUX_DEFAULT中添加crashkernel=512M"></a>1. 编辑/etc/default/grub文件，在GRUB_CMDLINE_LINUX_DEFAULT中添加crashkernel=512M</h2><pre class="line-numbers language-none"><code class="language-none">GRUB_CMDLINE_LINUX_DEFAULT="quiet apparmor=1 security=apparmor crashkernel=512M udev.log_priority=3"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-重新生成引导配置，更新grub引导选项"><a href="#2-重新生成引导配置，更新grub引导选项" class="headerlink" title="2. 重新生成引导配置，更新grub引导选项"></a>2. 重新生成引导配置，更新grub引导选项</h2><pre class="line-numbers language-none"><code class="language-none">sudo update-grub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-配置成功后可以在-proc-iomem中看到Crash-Kernel段"><a href="#3-配置成功后可以在-proc-iomem中看到Crash-Kernel段" class="headerlink" title="3. 配置成功后可以在/proc/iomem中看到Crash Kernel段"></a>3. 配置成功后可以在<code>/proc/iomem</code>中看到<code>Crash Kernel</code>段</h2><pre class="line-numbers language-none"><code class="language-none">00000000-00000000 : System ROM00000000-00000000 : System RAM00000000-00000000 : Crash kernel00000000-00000000 : ACPI Tables00000000-00000000 : ACPI Non-volatile Storage00000000-00000000 : System RAM00000000-00000000 : PCI Bus 0000:00<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="添加kdump的服务"><a href="#添加kdump的服务" class="headerlink" title="添加kdump的服务"></a>添加kdump的服务</h1><p>添加kdump需要在<code>/etc/systemd/system/</code>目录下添加一个<code>kdump.service</code>的文件。可以参照arch wiki上的介绍来，下面是我的配置</p><pre class="line-numbers language-none"><code class="language-none">[Unit]Description=Load dump capture kernelAfter=local-fs.target[Service]ExecStart=/usr/bin/kexec -p /boot/vmlinuz-isatis --initrd=/boot/initramfs-isatis.img --append="root=/dev/sda1 single irqpoll reset_devices"Type=oneshot[Install]WantedBy=multi-user.target<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置好以后可以启动服务</p><pre class="line-numbers language-none"><code class="language-none">systemctl enable kdump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="测试crash配置"><a href="#测试crash配置" class="headerlink" title="测试crash配置"></a>测试crash配置</h1><p>正常重启后我们添加的kdump服务就会运行，可以通过<code>cat /sys/kernel/kexec_crash_loaded</code>来查看是否正常运行，值为1就是在正常运行了。如果没有运行可以手动执行下服务中<code>ExecStart</code>后面的指令，看看报错信息。</p><pre class="line-numbers language-none"><code class="language-none">❯ cat /sys/kernel/kexec_crash_loaded1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>配置好以后可以手动触发来测试配置</p><pre class="line-numbers language-none"><code class="language-none">echo c &gt; /proc/sysrq-trigger<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个内核挂掉后，如果正常就可以进入第二个内核，在第二个内核中的<code>/proc/vmcore</code>就是第一个内核的内存镜像文件，可以通过下面的命令保存crash文件，可以通过crash工具来分析这个文件，研究内核崩溃的原因。</p><pre class="line-numbers language-none"><code class="language-none">cp /proc/vmcore ./crash.dump<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>arck wiki上提供了一个<code>makedumpfile</code>工具可以保存小一点的内核，空间拮据的可以试试，我暂时够用，就没有用。arch wiki上还提供了一个自动保存crash dump的配置配置，后面有需要再研究，暂时手动保存够用了。</p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>最开始按照arch wiki上的kexec命令进行配置，crash掉后无法进入第二个内核，后来在arch的bbs找到一个同样的问题，<a href="https://bbs.archlinux.org/viewtopic.php?id=182324">Unable to setup Kdump.</a><br>因为我用的是虚拟机，貌似设置CPU数量大于1都无法正常进入第二个内核，可能是虚拟机的bug。后面按照那哥们的配置，把虚拟的CPU数量改为1，正常进入了第二个内核。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Kdump和crash&quot;&gt;&lt;a href=&quot;#Kdump和crash&quot; class=&quot;headerlink&quot; title=&quot;Kdump和crash&quot;&gt;&lt;/a&gt;Kdump和crash&lt;/h1&gt;&lt;p&gt;我们的程序崩溃的时候可以设置生成core文件，通过分析core文件，</summary>
      
    
    
    
    
    <category term="manjaro" scheme="http://www.isatis.top/tags/manjaro/"/>
    
    <category term="arch" scheme="http://www.isatis.top/tags/arch/"/>
    
    <category term="crash" scheme="http://www.isatis.top/tags/crash/"/>
    
    <category term="kdump" scheme="http://www.isatis.top/tags/kdump/"/>
    
  </entry>
  
  <entry>
    <title>manjaro(arch linux)更换内核</title>
    <link href="http://www.isatis.top/2021/05/09/arch-linux-geng-huan-nei-he/"/>
    <id>http://www.isatis.top/2021/05/09/arch-linux-geng-huan-nei-he/</id>
    <published>2021-05-09T08:50:05.000Z</published>
    <updated>2021-05-15T14:54:19.661Z</updated>
    
    <content type="html"><![CDATA[<p>我使用的manjaro发行版，想要自己做更改内核选项做些实验，需要手动编译内核，manjaro跟arch linux 是一个妈生的，所以可以参考arch linux上更换内核的<a href="https://wiki.archlinux.org/title/Kernel/Traditional_compilation#Preparation">wiki</a>来进行操作。不得不说，arch 的wiki真的给力，aur也爽。</p><h1 id="下载解压内核"><a href="#下载解压内核" class="headerlink" title="下载解压内核"></a>下载解压内核</h1><p>从linux kernel 的官网上下载你需要版本的内核（自己现在使用的内核版本可以使用uname -r查看，保险一点可以下载跟当前系统版本一样的内核)，例如我的是5.11.16，就下载5.11.16版本的。下载得到linux-5.11.16.tar.gz<br>下载后解压内核。官网下载慢可以在国内的镜像站上找找，例如中科大的镜像源。</p><pre class="line-numbers language-none"><code class="language-none">tar -zxvf linux-5.11.16.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压进入对应的目录，并clean下，确保整个内核是干净的</p><pre class="line-numbers language-none"><code class="language-none">cd linux-5.11.16make mrproper<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h1><p>内核编译是依靠.config文件进行功能的裁剪的，为了确保新编出来的内核配置可以在当前的系统正常跑起来，所以我们需要使用当前系统的默认配置。可以通过下面这条命令把当前系统正在用的内核编译选项保存下来。</p><pre class="line-numbers language-none"><code class="language-none">zcat /proc/config.gz &gt; .config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>保存后使用make menuconfig 配置下自己想要的选项，具体配置需要看个人需要。其中 CONFIG_LOCALVERSION 和 CONFIG_DEFAULT_HOSTNAME 建议改为自定义的内容，避免和当前系统的内核文件冲突。</p><pre class="line-numbers language-none"><code class="language-none">CONFIG_INIT_ENV_ARG_LIMIT=32# CONFIG_COMPILE_TEST is not setCONFIG_LOCALVERSION="-isatis"# CONFIG_LOCALVERSION_AUTO is not setCONFIG_BUILD_SALT=""CONFIG_HAVE_KERNEL_GZIP=yCONFIG_KERNEL_ZSTD=yCONFIG_DEFAULT_INIT=""CONFIG_DEFAULT_HOSTNAME="isatis"CONFIG_SWAP=y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><p>配置好后，直接make -j9就可以开始编译了，-j9可以有一定的加速，后面的数字需要看你的cpu核心数，例如你是两核的CPU,就可以用 make -j9</p><pre class="line-numbers language-none"><code class="language-none">make -j8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="编译安装必要的模块"><a href="#编译安装必要的模块" class="headerlink" title="编译安装必要的模块"></a>编译安装必要的模块</h1><p>没什么好说的，两条编译指令直接敲就完事了</p><pre class="line-numbers language-none"><code class="language-none">make modules &amp;&amp; make modules_install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="拷贝编译好的内核到-boot目录"><a href="#拷贝编译好的内核到-boot目录" class="headerlink" title="拷贝编译好的内核到/boot目录"></a>拷贝编译好的内核到/boot目录</h1><p>实际启动的是生成的bzImage内核，我的是x86_64的就用如下命令拷贝</p><pre class="line-numbers language-none"><code class="language-none">cp -v arch/x86_64/boot/bzImage /boot/vmlinuz-isatis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这里文件命令最好是vmlinuz-xxx形式的，-后的可以自定义，前面的用vmlinuz,不然后面生成.img文件的时候可能会出错</p><h1 id="制作初始化内在盘"><a href="#制作初始化内在盘" class="headerlink" title="制作初始化内在盘"></a>制作初始化内在盘</h1><p>首先是拷贝配置文件，后面可以根据这个配置文件自动生成 ram disk文件。</p><pre class="line-numbers language-none"><code class="language-none">cd /etc/mkinitcpio.dcp linux510.preset isatis.preset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后编辑这个文件,ALL_kver后面的换成刚编译的内核，default_image后面的就是启动用的，fallback_image是用来回滚用的，都改成自定义的。</p><pre class="line-numbers language-none"><code class="language-none"># mkinitcpio preset file for the 'linux510' packageALL_config="/etc/mkinitcpio.conf"ALL_kver="/boot/vmlinuz-isatis"PRESETS=('default' 'fallback')#default_config="/etc/mkinitcpio.conf"default_image="/boot/initramfs-isatis.img"#default_options=""#fallback_config="/etc/mkinitcpio.conf"fallback_image="/boot/initramfs-isatis-fallback.img"fallback_options="-S autodetect"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用mkinitcpio自动处理,参数就是刚才哪个.preset文件的名称</p><pre class="line-numbers language-none"><code class="language-none">mkinitcpio isatis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="更新grub"><a href="#更新grub" class="headerlink" title="更新grub"></a>更新grub</h1><p>直接使用update-grub命令更新下grub引导信息就好了，grub会根据生成的.img自动更新</p><pre class="line-numbers language-none"><code class="language-none">update-grub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="重启选择自己编译的内核"><a href="#重启选择自己编译的内核" class="headerlink" title="重启选择自己编译的内核"></a>重启选择自己编译的内核</h1><p>启动的grub高级选项可以看到刚才添加的内核initramfs-isatis，选择这个内核启动就可以通过到刚才编译的内核启动了<br>启动后右以用uname -r看看当前使用的内核，是不是刚才编译的。</p><pre class="line-numbers language-none"><code class="language-none">❯ uname -r5.11.16-isatis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我使用的manjaro发行版，想要自己做更改内核选项做些实验，需要手动编译内核，manjaro跟arch linux 是一个妈生的，所以可以参考arch linux上更换内核的&lt;a href=&quot;https://wiki.archlinux.org/title/Kernel/</summary>
      
    
    
    
    
    <category term="linux" scheme="http://www.isatis.top/tags/linux/"/>
    
    <category term="manjaro" scheme="http://www.isatis.top/tags/manjaro/"/>
    
    <category term="arch" scheme="http://www.isatis.top/tags/arch/"/>
    
    <category term="kernel" scheme="http://www.isatis.top/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>内存布局分析(2)</title>
    <link href="http://www.isatis.top/2021/01/02/nei-cun-bu-ju-fen-xi-2/"/>
    <id>http://www.isatis.top/2021/01/02/nei-cun-bu-ju-fen-xi-2/</id>
    <published>2021-01-02T01:19:39.000Z</published>
    <updated>2021-05-09T12:58:59.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存布局分析-2"><a href="#内存布局分析-2" class="headerlink" title="内存布局分析(2)"></a>内存布局分析(2)</h1><span id="more"></span><h1 id="未初始化的全局变量（-bss）"><a href="#未初始化的全局变量（-bss）" class="headerlink" title="未初始化的全局变量（.bss）"></a>未初始化的全局变量（.bss）</h1><p>没有初始化过的变量被放在.bss区。这部分存储时没的占用磁盘空间，程序运行起来，这段会被map到一个虚拟地址上。因为没有实际的文件存储，所以映射出来也没有文件背景，但它们通常都会紧跟着有其对应的文件背景片段。对应到smaps的信息，可以猜测下面这两段可能就是mm和libmm.so的.bss段映射。</p><p>mm</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">01022000-02022000 rw-p 00000000 00:00 0Size:              16384 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   0 kBPss:                   0 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         0 kBReferenced:            0 kBAnonymous:             0 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd wr mr mw me ac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>libmm.so</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">b5f18000-b6f18000 rw-p 00000000 00:00 0Size:              16384 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   0 kBPss:                   0 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         0 kBReferenced:            0 kBAnonymous:             0 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd wr mr mw me ac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li> 同样的，要确认这两段的“身份”，首先看下对应的段表</li></ol><ul><li><p>mm</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[23] .bss              NOBITS          01021040 1001040 1000004 00  WA  0   0  4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  mm段表的地址是01021040，smaps中的地址段是01022000-02022000。01021040是小于01022000的，相差4032。是否就说明这段不是.bss段呢？别急，“.bss”段的长度是0x1000004,换算下来也差不多是16384KB。大小上是对得上的。另外我们打印出的gBss的地址为0x1021044，与段表上的似乎对得上。我们申请的gBss大小为4096 × 1024。大小为4096KB。实际通过gBss的我们就可以确认gBss有一部分空间是到了01022000-02022000这里面。那行如何验证呢？其实也很简单，我们将gBss变量全部初始化有内容，这时linux就会为我们分配出这4096KB的物理内存，如果这段占用的物理内存变大了，不就证明了我们的猜想了吗？</p></li><li><p>libmm.so</p>  <pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[20] .bss              NOBITS          01011040 1001040 1000004 00  WA  0   0  4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  libmm.so段表的地址是01011040。smaps中地址段是b5f18000-b6f18000，libmm.so加载的基地址是0xb4f06000。那么这段减去基地址后实际就是0x1012000-0x2012000。01011040与b5f18000还是相差了4032。<br>  打印出的0xb5f17044，减去加载的基地址后为0x1011044。与mm的情况一样，同样我们也可以使用mm一样的方法去确认。</p></li></ul><ol start="2"><li> 补充</li></ol><p>例子中因为是只一个变量，我们可以直接知道这个变量。但实际工程中变量诸多，我们可以通过.symtab中的Ndx来寻找对应的变量。比如mm中.bss段的为23。那么在.symtab中就不难定位到gBss。<br>mm</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Num:    Value  Size Type    Bind   Vis      Ndx Name89: 01021044 0x1000000 OBJECT  GLOBAL DEFAULT   23 gBss<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样的，libmm.so中.bss段是20。在对应的.symtab中也不难定位到gBssLib</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Num:    Value  Size Type    Bind   Vis      Ndx Name86: 01011044 0x1000000 OBJECT  GLOBAL DEFAULT   20 gBssLi<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;内存布局分析-2&quot;&gt;&lt;a href=&quot;#内存布局分析-2&quot; class=&quot;headerlink&quot; title=&quot;内存布局分析(2)&quot;&gt;&lt;/a&gt;内存布局分析(2)&lt;/h1&gt;</summary>
    
    
    
    
    <category term="内存优化&amp;分析" scheme="http://www.isatis.top/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96-%E5%88%86%E6%9E%90/"/>
    
    <category term="内存优化" scheme="http://www.isatis.top/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
    <category term="内存管理" scheme="http://www.isatis.top/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>内存布局分析(1)</title>
    <link href="http://www.isatis.top/2021/01/02/nei-cun-bu-ju-fen-xi-1/"/>
    <id>http://www.isatis.top/2021/01/02/nei-cun-bu-ju-fen-xi-1/</id>
    <published>2021-01-02T01:19:39.000Z</published>
    <updated>2021-05-09T12:59:11.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存布局分析-1"><a href="#内存布局分析-1" class="headerlink" title="内存布局分析(1)"></a>内存布局分析(1)</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>内存资源是宝贵的，内存能少用决不多用。而想要如何优化内存使用的前提就是要找到是哪里使用了内存？用了多大了内存？需要注意的是，我们并不是调用malloc申请了的大的内存，就一定占用了那么大的内存。因为linux会在我们用到的时候才会给我们分配实际的物理内存。例如下面的，虽然申请了4100kB的虚拟地址空间，但实际使用的物理内存也只有4KB。所以申请的内存大小不等于实际使用的物理内存，某些时候申请了很多，但实际根本不会用到。建议的思路在于看到哪一段占用了物理内存，再对应到代码中去，对这块业务进行优化。而通过查看进程的smaps,可以看到程序实际运行起来，物理内存实际占用情况。但问题就在于smap出来的信息，知道了哪个地址片段占用了大量的内存（Rss值）但是我只有一个地址信息，而如何确认smaps对应到代码中的变量或者malloc操作呢？下面以一个实例来分析下</p><p>代码仓库：<a href="https://github.com/isatispro/mm.git">https://github.com/isatispro/mm.git</a></p><p>实验平台：树莓派4B</p><h2 id="2-主要内存消耗点及优化点"><a href="#2-主要内存消耗点及优化点" class="headerlink" title="2.主要内存消耗点及优化点"></a>2.主要内存消耗点及优化点</h2><p>程序 = 代码 + 数据结构。真正代码段上能优化的很少，数据结构的核心还是在数据上，所以分析和优化的点多数都在数据上。数据的优化点可以从我们定义的全局变量，调用的malloc申请的内存上先下手,其中全局变量又会分到.data段和.bss段，而malloc又会分为brk的内存和mmap的内存。</p><h3 id="1-全局变量"><a href="#1-全局变量" class="headerlink" title="1. 全局变量"></a>1. 全局变量</h3><p>mm</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">PAGE_SIZE</span> <span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span>#define <span class="token function">SIZE_1K</span> <span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token keyword">char</span> <span class="token operator">*</span>pText <span class="token operator">=</span> </span><span class="token string">"The  mallopt()  function  adjusts parameters that control the behavior of the memory-allocation functions (see malloc(3)).  The param argument specifies the parameter to be modi‐fied, and value specifies the new value for that parameter."</span><span class="token expression"><span class="token punctuation">;</span></span></span><span class="token keyword">int</span> gData<span class="token punctuation">[</span>PAGE_SIZE <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> gBss<span class="token punctuation">[</span>PAGE_SIZE <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>libmm.so</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">PAGE_SIZE</span> <span class="token punctuation">(</span><span class="token number">4096</span><span class="token punctuation">)</span><span class="token keyword">char</span> <span class="token operator">*</span>pTextLib <span class="token operator">=</span> </span><span class="token string">"The  mallopt()  function  adjusts parameters that control the behavior of the memory-allocation functions (see malloc(3)).  The param argument specifies the parameter to be modi‐fied, and value specifies the new value for that parameter."</span><span class="token expression"><span class="token punctuation">;</span></span></span><span class="token keyword">int</span> gDataLib<span class="token punctuation">[</span>PAGE_SIZE <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> gBssLib<span class="token punctuation">[</span>PAGE_SIZE <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>在函数内部定义的变量，会被分配在栈空间。而已经初始化的全局变量放在.data段，未初始化的在.bss段，这部分会在程序加载时就映射到内存空间上。</p><h4 id="已初始化的全局变量（-data）"><a href="#已初始化的全局变量（-data）" class="headerlink" title="已初始化的全局变量（.data）"></a>已初始化的全局变量（.data）</h4><p>先看下smaps的情况</p><p>mm</p><pre class="line-numbers language-none"><code class="language-none">00010000-00011000 r-xp 00000000 00:28 2752530    /mnt/nfs/mm/mmSize:                  4 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   4 kBPss:                   4 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         4 kBPrivate_Dirty:         0 kBReferenced:            4 kBAnonymous:             0 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd ex mr mw me dw00020000-00021000 r--p 00000000 00:28 2752530    /mnt/nfs/mm/mmSize:                  4 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   4 kBPss:                   4 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         4 kBReferenced:            4 kBAnonymous:             4 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd mr mw me dw ac00021000-01022000 rw-p 00001000 00:28 2752530    /mnt/nfs/mm/mmSize:              16388 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                  64 kBPss:                  64 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:        56 kBPrivate_Dirty:         8 kBReferenced:           64 kBAnonymous:             8 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd wr mr mw me dw ac01022000-02022000 rw-p 00000000 00:00 0Size:              16384 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   0 kBPss:                   0 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         0 kBReferenced:            0 kBAnonymous:             0 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd wr mr mw me ac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>limmm.so</p><pre class="line-numbers language-none"><code class="language-none">b4f06000-b4f07000 r-xp 00000000 00:28 2752531    /mnt/nfs/mm/libmm.soSize:                  4 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   4 kBPss:                   4 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         4 kBPrivate_Dirty:         0 kBReferenced:            4 kBAnonymous:             0 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd ex mr mw meb4f07000-b4f16000 ---p 00001000 00:28 2752531    /mnt/nfs/mm/libmm.soSize:                 60 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   0 kBPss:                   0 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         0 kBReferenced:            0 kBAnonymous:             0 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: mr mw meb4f16000-b4f17000 r--p 00000000 00:28 2752531    /mnt/nfs/mm/libmm.soSize:                  4 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   4 kBPss:                   4 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         4 kBReferenced:            4 kBAnonymous:             4 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd mr mw me acb4f17000-b5f18000 rw-p 00001000 00:28 2752531    /mnt/nfs/mm/libmm.soSize:              16388 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                  64 kBPss:                  64 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:        56 kBPrivate_Dirty:         8 kBReferenced:           64 kBAnonymous:             8 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd wr mr mw me acb5f18000-b6f18000 rw-p 00000000 00:00 0Size:              16384 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                   0 kBPss:                   0 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:         0 kBPrivate_Dirty:         0 kBReferenced:            0 kBAnonymous:             0 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd wr mr mw me ac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们的全局变量一定是可读可写的，所以它的权限必定有读写。而且因为已经初始化的全局变量是有实际的数据内容，并且保存在程序的文件中，所以这部分内存是有文件背景的映射，所以有两段我们可以猜测它会是.data段的映射。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">00021000-01022000 rw-p 00001000 00:28 2752530    /mnt/nfs/mm/mmSize:              16388 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                  64 kBPss:                  64 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:        56 kBPrivate_Dirty:         8 kBReferenced:           64 kBAnonymous:             8 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd wr mr mw me dw ac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">b4f17000-b5f18000 rw-p 00001000 00:28 2752531    /mnt/nfs/mm/libmm.soSize:              16388 kBKernelPageSize:        4 kBMMUPageSize:           4 kBRss:                  64 kBPss:                  64 kBShared_Clean:          0 kBShared_Dirty:          0 kBPrivate_Clean:        56 kBPrivate_Dirty:         8 kBReferenced:           64 kBAnonymous:             8 kBLazyFree:              0 kBAnonHugePages:         0 kBShmemPmdMapped:        0 kBFilePmdMapped:        0 kBShared_Hugetlb:        0 kBPrivate_Hugetlb:       0 kBSwap:                  0 kBSwapPss:               0 kBLocked:                0 kBTHPeligible:0VmFlags: rd wr mr mw me ac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="再看下段表"><a href="#再看下段表" class="headerlink" title="再看下段表"></a>再看下段表</h5><p>mm</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[22] .data             PROGBITS        00021034 001034 100000c 00  WA  0   0  4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>libmm.so</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">[19] .data             PROGBITS        00011038 001038 1000008 00  WA  0   0  4<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>  mm</li></ul><p>.data 段表的Addr是00021034。smaps段的地址是 00021000-01022000。00021034是位于00021000-01022000中间的。</p><ul><li>  libmm.so</li></ul><p>.data 段表中的Addr是00011038。而smaps中的地址是 b4f17000-b5f18000。需要注意的是动态库段表中的不是真正的虚拟地址。计算时需要减去动态库的基地址。从smaps看到libmm.so加载的基地址是 b4f06000 。b4f17000-b5f18000减去基址址为 00011000-1012000。00011038也是位于00011000-1012000内。</p><p>然后看看全局变量的符号表，<br>可以mm看到gData这个变量的地址是00021040，位于地址范围00021000-01022000内</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">110: 02021044     0 NOTYPE  GLOBAL DEFAULT   23 _end111: 00010478     0 FUNC    GLOBAL DEFAULT   13 _start112: 02021044     0 NOTYPE  GLOBAL DEFAULT   23 __end__113: 01021040     0 NOTYPE  GLOBAL DEFAULT   23 __bss_start114: 00010568   192 FUNC    GLOBAL DEFAULT   13 main115: 00021040 0x1000000 OBJECT  GLOBAL DEFAULT   22 gData116: 01021040     0 OBJECT  GLOBAL HIDDEN    22 __TMC_END__117: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable118: 00000000     0 FUNC    GLOBAL DEFAULT  UND abort@@GLIBC_2.4119: 000103ec     0 FUNC    GLOBAL HIDDEN    11 _init<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>libmm.so 中gDataLib的0001103c，位于地址范围00011000-1012000内</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">75: 00000384     0 NOTYPE  LOCAL  DEFAULT   10 $d76: 00000388     0 NOTYPE  LOCAL  DEFAULT   10 $a77: 0001103c 0x1000000 OBJECT  GLOBAL DEFAULT   19 gDataLib78: 00000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@@GLIBC_2.479: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab80: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@@GLIBC_2.481: 0101103c     4 OBJECT  GLOBAL DEFAULT   19 pTextLib82: 00000000     0 FUNC    GLOBAL DEFAULT  UND puts@@GLIBC_2.483: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__84: 000004dc   124 FUNC    GLOBAL DEFAULT   11 mm_lib_init85: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable86: 01011044 0x1000000 OBJECT  GLOBAL DEFAULT   20 gBssLib<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在基本可以确认smaps中00021000-01022000和b4f17000-b5f18000这两段分别是mm和libmm.so的.data段的映射。它们现在分别占用了64KB。虽然它们申请的远大于这个值，但实际上就占用的物理内存并不多。另外在代码里并没有去该变过这段地址内的内容，所以它们的Dirty部分都不大，而这些页面的，后续都是可以交换被拿出来给其它地方用的。</p><p>虽然分析到这里基本可以确认，但我们仍然可以在代码里打印出这两个变量的地址确认下。gData的地址为0x21040，和通过符号表里查到的是一样的，另外gDataLib的地址为0xb4f1703c，减去libmm.so加载的基址0xb4f06000，得到0x1103c，也与符号表里查到的一样。</p><p>mm:</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">data addr:0x21040<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>libmm.so</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">data addr:0xb4f1703c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;内存布局分析-1&quot;&gt;&lt;a href=&quot;#内存布局分析-1&quot; class=&quot;headerlink&quot; title=&quot;内存布局分析(1)&quot;&gt;&lt;/a&gt;内存布局分析(1)&lt;/h1&gt;&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="内存优化&amp;分析" scheme="http://www.isatis.top/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96-%E5%88%86%E6%9E%90/"/>
    
    <category term="内存优化" scheme="http://www.isatis.top/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
    <category term="内存管理" scheme="http://www.isatis.top/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>linux内核中的红黑树</title>
    <link href="http://www.isatis.top/2020/10/07/linux-nei-he-zhong-de-hong-hei-shu/"/>
    <id>http://www.isatis.top/2020/10/07/linux-nei-he-zhong-de-hong-hei-shu/</id>
    <published>2020-10-06T16:00:00.000Z</published>
    <updated>2021-05-09T09:50:05.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-内核中的红黑树"><a href="#Linux-内核中的红黑树" class="headerlink" title="Linux 内核中的红黑树"></a><a href="#Linux-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91" title="Linux 内核中的红黑树"></a>Linux 内核中的红黑树</h1><span id="more"></span><p>“#1-红黑树是什么玩意？” class=”headerlink” title=”1. 红黑树是什么玩意？”&gt;1. 红黑树是什么玩意？</p><p>红黑树是一种自平衡的二叉搜索树，它等价于2-3-4树，相对于AVL树，它有更好的插入与删除性能，在Linux内核中被广泛使用。Linux内核中有已经实现好的红黑树，可以直接使用，并且内核文档中也有使用说明。关于红黑树的一些资料，可以参考<a href="http://en.wikipedia.org/wiki/Red-black_tree">红黑树在wiki上的文档</a></p><h2 id="2-代码在哪儿？"><a href="#2-代码在哪儿？" class="headerlink" title="2. 代码在哪儿？"></a><a href="#2-%E4%BB%A3%E7%A0%81%E5%9C%A8%E5%93%AA%E5%84%BF%EF%BC%9F" title="2. 代码在哪儿？"></a>2. 代码在哪儿？</h2><h3 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件:"></a><a href="#%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6" title="代码文件:"></a><strong>代码文件:</strong></h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lib/rbtree.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="头文件："><a href="#头文件：" class="headerlink" title="头文件："></a><a href="#%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%9A" title="头文件："></a><strong>头文件：</strong></h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">include/linux/rbtree.hinclude/linux/rbtree_augmented.h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要移植红黑树只需要将上面几个文件拷出来，再对一些用到的宏进行处理就行了</p><h2 id="3-节点解析"><a href="#3-节点解析" class="headerlink" title="3. 节点解析"></a><a href="#3-%E8%8A%82%E7%82%B9%E8%A7%A3%E6%9E%90" title="3. 节点解析"></a>3. 节点解析</h2><p>第一次查看内核中红黑树的节点，觉得很奇怪，因为它简单了！抛开红黑树本身，这是它实现的高明之处，也是难点。wiki中红黑树的节点定义是这样的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">color_t</span> <span class="token punctuation">{</span> BLACK<span class="token punctuation">,</span> RED <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>  Node<span class="token operator">*</span> parent<span class="token punctuation">;</span>  Node<span class="token operator">*</span> left<span class="token punctuation">;</span>  Node<span class="token operator">*</span> right<span class="token punctuation">;</span>  <span class="token keyword">enum</span> <span class="token class-name">color_t</span> color<span class="token punctuation">;</span>  <span class="token keyword">int</span> key<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在linux内核中，红黑树的节点定义是这样的</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span>  __rb_parent_color<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>rb_right<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>rb_left<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* The alignment might seem pointless, but allegedly CRIS needs it */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以看到，内核中的红黑树相比普通的定义少了两个成员，普通的有5个，到了这边就只有3个了，那其它2个去哪儿了？首先是指向父节点的指针及节点颜色，对比普通定义，Linux内核中只有一个节点<strong>__rb_parent_color</strong>，从命名猜想可能是这一个成员干了人家两个成员的事？先看看获取父节点和获取当前节点颜色是如何实现的</p><h3 id="1-parent与color节点实现"><a href="#1-parent与color节点实现" class="headerlink" title="1. parent与color节点实现"></a><a href="#1-parent%E4%B8%8Ecolor%E8%8A%82%E7%82%B9%E5%AE%9E%E7%8E%B0" title="1. parent与color节点实现"></a>1. <em>parent与color节点实现</em></h3><h4 id="获取父节点"><a href="#获取父节点" class="headerlink" title="获取父节点"></a><a href="#%E8%8E%B7%E5%8F%96%E7%88%B6%E8%8A%82%E7%82%B9" title="获取父节点"></a>获取父节点</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">rb_parent</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">3</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="获取节点颜色"><a href="#获取节点颜色" class="headerlink" title="获取节点颜色"></a><a href="#%E8%8E%B7%E5%8F%96%E8%8A%82%E7%82%B9%E9%A2%9C%E8%89%B2" title="获取节点颜色"></a>获取节点颜色</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token expression">RB_RED0#defineRB_BLACK1#define <span class="token function">__rb_color</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span>#define <span class="token function">__rb_is_black</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span>  <span class="token function">__rb_color</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span>#define <span class="token function">__rb_is_red</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">__rb_color</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">)</span>#define <span class="token function">rb_color</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span>       <span class="token function">__rb_color</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color<span class="token punctuation">)</span>#define <span class="token function">rb_is_red</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span>      <span class="token function">__rb_is_red</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color<span class="token punctuation">)</span>#define <span class="token function">rb_is_black</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span>    <span class="token function">__rb_is_black</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="父节点获取分析"><a href="#父节点获取分析" class="headerlink" title="父节点获取分析"></a><a href="#%E7%88%B6%E8%8A%82%E7%82%B9%E8%8E%B7%E5%8F%96%E5%88%86%E6%9E%90" title="父节点获取分析"></a>父节点获取分析</h4><p>要注意的是long类型在不同系统的长度是不一样的，在32位系统为32位，在64位系统为64位，下面以32位系统来作分析。父节点获取就是把<strong>__rb_parent_color</strong>中除了最后两位去掉的内容去掉，如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token number">3</span>： <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0011</span><span class="token operator">~</span><span class="token number">3</span>： <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1100</span> <span class="token comment">/* ~3就是最后两位为0的数 */</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">3</span> <span class="token comment">/* 此处对~3进行 &amp; 运算就是把(r)-&gt;__rb_parent_color的最后两位清掉 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="节点颜色的获取分析"><a href="#节点颜色的获取分析" class="headerlink" title="节点颜色的获取分析"></a><a href="#%E8%8A%82%E7%82%B9%E9%A2%9C%E8%89%B2%E7%9A%84%E8%8E%B7%E5%8F%96%E5%88%86%E6%9E%90" title="节点颜色的获取分析"></a>节点颜色的获取分析</h4><p>节点颜色最后都是将<strong>__rb_parent_color</strong>给到<strong>__rb_color</strong>这个宏来实现，<strong>__rb_color</strong>中将<strong>__rb_parent_colorr</strong>与1进行 &amp; 运算，其实就是将最后一位取出，最后一位就是节点的颜色。</p><h4 id="为什么父节点可以和颜色用同一个成员变量？"><a href="#为什么父节点可以和颜色用同一个成员变量？" class="headerlink" title="为什么父节点可以和颜色用同一个成员变量？"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%88%B6%E8%8A%82%E7%82%B9%E5%8F%AF%E4%BB%A5%E5%92%8C%E9%A2%9C%E8%89%B2%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%9F" title="为什么父节点可以和颜色用同一个成员变量？"></a>为什么父节点可以和颜色用同一个成员变量？</h4><p><strong>__rb_parent_colorr</strong>这个成员的前30位存了父节点的地址，最后一位存了节点的颜色，节点颜色不难理解，那么为什么在最后一写入颜色不会影响父节点的地址呢？32位系统的地址明明是32位，为什么只用到30位？</p><p>其实最后两位真不会用到，因为在32位的操作系统中，这个结构体在内存中是按照4字节对齐存储，两个指针变量4字节，long类型的变量同样也是占用4节点，而4字节对齐下，它们的地址都会是4的倍数，相应的地址最后两位一定为0。另外值得注意的是虽然这里进行了手动对齐*<strong>attribute</strong>((aligned(sizeof(long))))*，但即使不进行手动对齐，还是会4字节对齐，注释说根据CRIS会需要用到。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-||      __rb_parent_colorr       |       rb_right                |        rb_left                |<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>相应的在64位系统上，<strong>rb_node</strong>会按照8字节对齐存储，届时最后三位都不会用到，所以在64位系统上也同样适用。</p><h3 id="2-节点key"><a href="#2-节点key" class="headerlink" title="2. 节点key"></a><a href="#2-%E8%8A%82%E7%82%B9key" title="2. 节点key"></a>2. <strong>节点key</strong></h3><p>红黑树的节点并没有定义节点内容的成员，如果要使用红黑树就需要将<strong>rb_node</strong>这个节点内嵌到你的结构体中，获取节点时由<strong>rb_entry</strong>或者是<strong>container_of</strong>宏来获取自定义结构体的entry地址</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> <span class="token operator">*</span>keystring<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>而 <strong>rb_entry</strong>实质也是<strong>container_of</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">definerb</span><span class="token expression"><span class="token function">_entry</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> type<span class="token punctuation">,</span> member<span class="token punctuation">)</span> <span class="token function">container_of</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> type<span class="token punctuation">,</span> member）</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>container_of</strong> 这个宏可算是内核中的一个绝活了，例如上面定义的mytype结构休，使用红黑树进行增删改查时，我们找到的得到的只有 <strong>rb_node</strong> 节点，我们可以通过 <strong>container_of</strong> 宏获取到对应的mytpye地址， <strong>container_of</strong> 的原理就是通过 <strong>rb_node</strong> 的地址减去其在结构体中的偏移，从而得到结构体的entry地址.这样也就相当节点的 <strong>key</strong> 从红黑树中取出，外挂在结构体中，只将红黑树的平衡操作统一实现。  </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">|---------|-------||keystring|rb_node|address_of(data) = address_of(rb_node) - offset_of(rb_node)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用 <strong>container_of</strong>宏操作  </p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mytype</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-内核文档中的一些操作示例"><a href="#3-内核文档中的一些操作示例" class="headerlink" title="3. 内核文档中的一些操作示例"></a><a href="#3-%E5%86%85%E6%A0%B8%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B" title="3. 内核文档中的一些操作示例"></a>3. <strong>内核文档中的一些操作示例</strong></h3><h4 id="插入操作-按普通二叉搜索树形式插入，再进行节点调整"><a href="#插入操作-按普通二叉搜索树形式插入，再进行节点调整" class="headerlink" title="插入操作,按普通二叉搜索树形式插入，再进行节点调整"></a><a href="#%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-%E6%8C%89%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%BD%A2%E5%BC%8F%E6%8F%92%E5%85%A5%EF%BC%8C%E5%86%8D%E8%BF%9B%E8%A1%8C%E8%8A%82%E7%82%B9%E8%B0%83%E6%95%B4" title="插入操作,按普通二叉搜索树形式插入，再进行节点调整"></a>插入操作,按普通二叉搜索树形式插入，再进行节点调整</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">my_insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token operator">*</span>new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>rb_node<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>parent <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">/* Figure out where to put new node */</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>this <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mytype</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>data<span class="token operator">-&gt;</span>keystring<span class="token punctuation">,</span> this<span class="token operator">-&gt;</span>keystring<span class="token punctuation">)</span><span class="token punctuation">;</span>parent <span class="token operator">=</span> <span class="token operator">*</span>new<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span><span class="token operator">-&gt;</span>rb_left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span><span class="token operator">-&gt;</span>rb_right<span class="token punctuation">)</span><span class="token punctuation">;</span>elsereturn FALSE<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* Add new node and rebalance tree. */</span><span class="token function">rb_link_node</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-&gt;</span>node<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> new<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">rb_insert_color</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-&gt;</span>node<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a><a href="#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C" title="删除操作"></a>删除操作</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">mysearch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mytree<span class="token punctuation">,</span> <span class="token string">"walrus"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">rb_erase</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-&gt;</span>node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mytree<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">myfree</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="其它操作接口"><a href="#其它操作接口" class="headerlink" title="其它操作接口"></a><a href="#%E5%85%B6%E5%AE%83%E6%93%8D%E4%BD%9C%E6%8E%A5%E5%8F%A3" title="其它操作接口"></a>其它操作接口</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_first</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 获取中序遍历的第一个节点，也就是最小的节点 */</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_last</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 获取中序遍历的最后一个节点，也就是最大的节点 */</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_next</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 获取当前节点的后继节点 */</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_prev</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 获取当前节点的前驱节点 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Linux-内核中的红黑树&quot;&gt;&lt;a href=&quot;#Linux-内核中的红黑树&quot; class=&quot;headerlink&quot; title=&quot;Linux 内核中的红黑树&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#Linux-%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E7%BA%A2%E9%BB%91%E6%A0%91&quot; title=&quot;Linux 内核中的红黑树&quot;&gt;&lt;/a&gt;Linux 内核中的红黑树&lt;/h1&gt;</summary>
    
    
    
    
    <category term="数据结构与算法" scheme="http://www.isatis.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="Algorithm" scheme="http://www.isatis.top/tags/Algorithm/"/>
    
    <category term="linux" scheme="http://www.isatis.top/tags/linux/"/>
    
    <category term="红黑树" scheme="http://www.isatis.top/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
    <category term="c语言" scheme="http://www.isatis.top/tags/c%E8%AF%AD%E8%A8%80/"/>
    
    <category term="节点对齐" scheme="http://www.isatis.top/tags/%E8%8A%82%E7%82%B9%E5%AF%B9%E9%BD%90/"/>
    
  </entry>
  
</feed>
