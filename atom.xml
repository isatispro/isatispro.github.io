<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Isatis&#39; Blog</title>
  
  <subtitle>路在远方</subtitle>
  <link href="http://www.isatis.top/atom.xml" rel="self"/>
  
  <link href="http://www.isatis.top/"/>
  <updated>2020-12-27T12:05:01.848Z</updated>
  <id>http://www.isatis.top/</id>
  
  <author>
    <name>Isatis.Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux内核中的红黑树</title>
    <link href="http://www.isatis.top/2020/10/07/2020-10-07-rbtree/"/>
    <id>http://www.isatis.top/2020/10/07/2020-10-07-rbtree/</id>
    <published>2020-10-06T16:00:00.000Z</published>
    <updated>2020-12-27T12:05:01.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-内核中的红黑树"><a href="#Linux-内核中的红黑树" class="headerlink" title="Linux 内核中的红黑树"></a>Linux 内核中的红黑树</h1><h2 id="1-红黑树是什么玩意？"><a href="#1-红黑树是什么玩意？" class="headerlink" title="1. 红黑树是什么玩意？"></a>1. 红黑树是什么玩意？</h2><p>红黑树是一种自平衡的二叉搜索树，它等价于2-3-4树，相对于AVL树，它有更好的插入与删除性能，在Linux内核中被广泛使用。Linux内核中有已经实现好的红黑树，可以直接使用，并且内核文档中也有使用说明。关于红黑树的一些资料，可以参考<a href="http://en.wikipedia.org/wiki/Red-black_tree">红黑树在wiki上的文档</a></p><h2 id="2-代码在哪儿？"><a href="#2-代码在哪儿？" class="headerlink" title="2. 代码在哪儿？"></a>2. 代码在哪儿？</h2><h3 id="代码文件"><a href="#代码文件" class="headerlink" title="代码文件:"></a><strong>代码文件:</strong></h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">lib/rbtree.c<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="头文件："><a href="#头文件：" class="headerlink" title="头文件："></a><strong>头文件：</strong></h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">include/linux/rbtree.hinclude/linux/rbtree_augmented.h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果要移植红黑树只需要将上面几个文件拷出来，再对一些用到的宏进行处理就行了</p><h2 id="3-节点解析"><a href="#3-节点解析" class="headerlink" title="3. 节点解析"></a>3. 节点解析</h2><p>第一次查看内核中红黑树的节点，觉得很奇怪，因为它简单了！抛开红黑树本身，这是它实现的高明之处，也是难点。wiki中红黑树的节点定义是这样的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">enum</span> <span class="token class-name">color_t</span> <span class="token punctuation">{</span> BLACK<span class="token punctuation">,</span> RED <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>  Node<span class="token operator">*</span> parent<span class="token punctuation">;</span>  Node<span class="token operator">*</span> left<span class="token punctuation">;</span>  Node<span class="token operator">*</span> right<span class="token punctuation">;</span>  <span class="token keyword">enum</span> <span class="token class-name">color_t</span> color<span class="token punctuation">;</span>  <span class="token keyword">int</span> key<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在linux内核中，红黑树的节点定义是这样的</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token punctuation">{</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span>  __rb_parent_color<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>rb_right<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>rb_left<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* The alignment might seem pointless, but allegedly CRIS needs it */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，内核中的红黑树相比普通的定义少了两个成员，普通的有5个，到了这边就只有3个了，那其它2个去哪儿了？首先是指向父节点的指针及节点颜色，对比普通定义，Linux内核中只有一个节点<strong>__rb_parent_color</strong>，从命名猜想可能是这一个成员干了人家两个成员的事？先看看获取父节点和获取当前节点颜色是如何实现的</p><h3 id="1-parent与color节点实现"><a href="#1-parent与color节点实现" class="headerlink" title="1. parent与color节点实现"></a>1. <em>parent与color节点实现</em></h3><h4 id="获取父节点"><a href="#获取父节点" class="headerlink" title="获取父节点"></a>获取父节点</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">rb_parent</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>   <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">3</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="获取节点颜色"><a href="#获取节点颜色" class="headerlink" title="获取节点颜色"></a>获取节点颜色</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token expression">RB_RED<span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token expression">RB_BLACK<span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__rb_color</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span>     <span class="token punctuation">(</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__rb_is_black</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span>  <span class="token function">__rb_color</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">__rb_is_red</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span>    <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">__rb_color</span><span class="token punctuation">(</span>pc<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">rb_color</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span>       <span class="token function">__rb_color</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">rb_is_red</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span>      <span class="token function">__rb_is_red</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression"><span class="token function">rb_is_black</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span>    <span class="token function">__rb_is_black</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="父节点获取分析"><a href="#父节点获取分析" class="headerlink" title="父节点获取分析"></a>父节点获取分析</h4><p>要注意的是long类型在不同系统的长度是不一样的，在32位系统为32位，在64位系统为64位，下面以32位系统来作分析。父节点获取就是把<strong>__rb_parent_color</strong>中除了最后两位去掉的内容去掉，如下：</p>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"> <span class="token number">3</span>： <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0000</span> <span class="token number">0011</span><span class="token operator">~</span><span class="token number">3</span>： <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1111</span> <span class="token number">1100</span> <span class="token comment">/* ~3就是最后两位为0的数 */</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token operator">-&gt;</span>__rb_parent_color <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">3</span> <span class="token comment">/* 此处对~3进行 &amp; 运算就是把(r)-&gt;__rb_parent_color的最后两位清掉 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="节点颜色的获取分析"><a href="#节点颜色的获取分析" class="headerlink" title="节点颜色的获取分析"></a>节点颜色的获取分析</h4><p>节点颜色最后都是将<strong>__rb_parent_color</strong>给到<strong>__rb_color</strong>这个宏来实现，<strong>__rb_color</strong>中将<strong>__rb_parent_colorr</strong>与1进行 &amp; 运算，其实就是将最后一位取出，最后一位就是节点的颜色。</p><h4 id="为什么父节点可以和颜色用同一个成员变量？"><a href="#为什么父节点可以和颜色用同一个成员变量？" class="headerlink" title="为什么父节点可以和颜色用同一个成员变量？"></a>为什么父节点可以和颜色用同一个成员变量？</h4><p>  <strong>__rb_parent_colorr</strong>这个成员的前30位存了父节点的地址，最后一位存了节点的颜色，节点颜色不难理解，那么为什么在最后一写入颜色不会影响父节点的地址呢？32位系统的地址明明是32位，为什么只用到30位？</p><p>  其实最后两位真不会用到，因为在32位的操作系统中，这个结构体在内存中是按照4字节对齐存储，两个指针变量4字节，long类型的变量同样也是占用4节点，而4字节对齐下，它们的地址都会是4的倍数，相应的地址最后两位一定为0。另外值得注意的是虽然这里进行了手动对齐*<strong>attribute</strong>((aligned(sizeof(long))))*，但即使不进行手动对齐，还是会4字节对齐，注释说根据CRIS会需要用到。</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-|-1byte-||      __rb_parent_colorr       |       rb_right                |        rb_left                |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>  相应的在64位系统上，<strong>rb_node</strong>会按照8字节对齐存储，届时最后三位都不会用到，所以在64位系统上也同样适用。</p><h3 id="2-节点key"><a href="#2-节点key" class="headerlink" title="2. 节点key"></a>2. <strong>节点key</strong></h3><p>  红黑树的节点并没有定义节点内容的成员，如果要使用红黑树就需要将<strong>rb_node</strong>这个节点内嵌到你的结构体中，获取节点时由<strong>rb_entry</strong>或者是<strong>container_of</strong>宏来获取自定义结构体的entry地址</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token punctuation">{</span>  <span class="token keyword">char</span> <span class="token operator">*</span>keystring<span class="token punctuation">;</span>  <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> node<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p> 而 <strong>rb_entry</strong>实质也是<strong>container_of</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span><span class="token expression"><span class="token function">rb_entry</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> type<span class="token punctuation">,</span> member<span class="token punctuation">)</span> <span class="token function">container_of</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> type<span class="token punctuation">,</span> member）</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>  <strong>container_of</strong> 这个宏可算是内核中的一个绝活了，例如上面定义的mytype结构休，使用红黑树进行增删改查时，我们找到的得到的只有 <strong>rb_node</strong> 节点，我们可以通过 <strong>container_of</strong> 宏获取到对应的mytpye地址， <strong>container_of</strong> 的原理就是通过 <strong>rb_node</strong> 的地址减去其在结构体中的偏移，从而得到结构体的entry地址.这样也就相当节点的 <strong>key</strong> 从红黑树中取出，外挂在结构体中，只将红黑树的平衡操作统一实现。<br>  </p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">|---------|-------||keystring|rb_node|address_of(data) = address_of(rb_node) - offset_of(rb_node)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br>使用  <strong>container_of</strong>宏操作<br>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mytype</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p></p><h3 id="3-内核文档中的一些操作示例"><a href="#3-内核文档中的一些操作示例" class="headerlink" title="3. 内核文档中的一些操作示例"></a>3. <strong>内核文档中的一些操作示例</strong></h3><h4 id="插入操作-按普通二叉搜索树形式插入，再进行节点调整"><a href="#插入操作-按普通二叉搜索树形式插入，再进行节点调整" class="headerlink" title="插入操作,按普通二叉搜索树形式插入，再进行节点调整"></a>插入操作,按普通二叉搜索树形式插入，再进行节点调整</h4>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">my_insert</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>root<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token operator">*</span>new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>root<span class="token operator">-&gt;</span>rb_node<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>parent <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token comment">/* Figure out where to put new node */</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>this <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">mytype</span><span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token function">strcmp</span><span class="token punctuation">(</span>data<span class="token operator">-&gt;</span>keystring<span class="token punctuation">,</span> this<span class="token operator">-&gt;</span>keystring<span class="token punctuation">)</span><span class="token punctuation">;</span>parent <span class="token operator">=</span> <span class="token operator">*</span>new<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span><span class="token operator">-&gt;</span>rb_left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>new <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>new<span class="token punctuation">)</span><span class="token operator">-&gt;</span>rb_right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">else</span><span class="token keyword">return</span> FALSE<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/* Add new node and rebalance tree. */</span><span class="token function">rb_link_node</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-&gt;</span>node<span class="token punctuation">,</span> parent<span class="token punctuation">,</span> new<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">rb_insert_color</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-&gt;</span>node<span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> TRUE<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4>  <pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">mytype</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">mysearch</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mytree<span class="token punctuation">,</span> <span class="token string">"walrus"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">rb_erase</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>data<span class="token operator">-&gt;</span>node<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mytree<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">myfree</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="其它操作接口"><a href="#其它操作接口" class="headerlink" title="其它操作接口"></a>其它操作接口</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_first</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 获取中序遍历的第一个节点，也就是最小的节点 */</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_last</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_root</span> <span class="token operator">*</span>tree<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 获取中序遍历的最后一个节点，也就是最大的节点 */</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_next</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 获取当前节点的后继节点 */</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span><span class="token function">rb_prev</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">rb_node</span> <span class="token operator">*</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 获取当前节点的前驱节点 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux-内核中的红黑树&quot;&gt;&lt;a href=&quot;#Linux-内核中的红黑树&quot; class=&quot;headerlink&quot; title=&quot;Linux 内核中的红黑树&quot;&gt;&lt;/a&gt;Linux 内核中的红黑树&lt;/h1&gt;&lt;h2 id=&quot;1-红黑树是什么玩意？&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://www.isatis.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="Algorithm" scheme="http://www.isatis.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Algorithm/"/>
    
    
    <category term="linux" scheme="http://www.isatis.top/tags/linux/"/>
    
    <category term="红黑树" scheme="http://www.isatis.top/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
    <category term="c语言" scheme="http://www.isatis.top/tags/c%E8%AF%AD%E8%A8%80/"/>
    
    <category term="节点对齐" scheme="http://www.isatis.top/tags/%E8%8A%82%E7%82%B9%E5%AF%B9%E9%BD%90/"/>
    
  </entry>
  
</feed>
